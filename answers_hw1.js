answers
'number' + 3 + 3 // number33

null + 3 // 3 ; null це фактично 0 і виконуємо операцію додавання  

5 && "qwerty" // false ; різні оператори тому false 

+'40' + +'2' + "hillel" /* 42hillel;  унарний плюс конвертує як число, тому 40 та 2 буде числами. 
Потім додається стрінга, яке буде не числовим значенням;
Унарні плюси мають пріоритет перед додаванням */

'10' - 5 === 6;  /* false ; === це оператор строгої рівності , повертає false якщо значенн різні .
 Цей оператор порівнює з типом та значенням. унарний мінус стрінгу преведе до числа - 10 -5 = 5. Далі 5 === 6 . Тут строге порівняння за типом та значенням. Значення у нас різні тому False*/

true + false /* 1 ;  додаються буленовы значення 1+0*/

'4px' - 3 //NaN ; змішане числове значення з стрінгою 

'4' - 3 // 1 - оператор "-" перетворить операнд на число 

'6' + 3 ** 0; //63; підрахунок зліва на право , знову ж таки + не приводить до числа стрінгу "6". тому відповідь 63

12 / '6' //2 ; оператор ділення переводить стрінгу в число тому 12/6 дасть результат 2

'10' + (5 === 6); /* 10false  - дія в дужках виконається першою , і тут оператор строгої нерівності поверне false. 
Далі по порядку стрінга і результат в дужках додаються . При чому оператор + застосований до стрінги просто об'єднає значення*/

null == '' // false ; null і пуста стрінга завжди приводяться до false 


3 ** (9 / 3); //27; спочатку дія в дужках , потім піднесення до степеня 

!!'false' == !!'true' // true ; порівняння двух значень. Після подвійного заперечення дані не змінилися 

0 || '0' && 1 // 1; поверне останнє значення, оператор &&  має пріоритет (тут трохи складно)

(+null == false) < 1; // false; унарний плюс приводить null до нуля , дія в дужках буде true. В результаті true < 1 вийде false , так як 1<1 - це неправдиве значення 

false && true || true // true; спочатку оператор && поверне false. далі оператор || буде порывнювати false та true . Повернеться true. || повертає тру , якщо хоча б одне істинне 

false && (false || true); // false ; спочатку дія в дужках дає true. Потім false && true - поверне false 

(+null == false) < 1 ** 5; /*false; унарний плюс ковертує +null до 0 , 0==false - перед порывнянням прриводится до спыльного типу 
і в результаті поверне true. 
1 ** 5 = до степеня в результаті 1 
true < 1 це буде теж саме , що 1 < 1 що даэ нам загальний результат FALSE*/

